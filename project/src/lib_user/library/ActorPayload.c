//
// ActorPayload.c by z64me
//
// system for fetching polymorphic actor payloads from rooms
//
// motivation:
//
//    actor lists in oot only store the following information for each actor:
//
//       type, position, rotation, params
//
//    'params' is limited to 16 bits (only two bytes!) of information, so
//    there isn't much room for you to hold your settings; if your actor
//    only needs to know its y rotation, you can repurpose x/z rotation
//    for additional configurability; finally, you can get pretty creative
//    with bitfields to store information for a surprising number of flags
//
//    for most actors, that is sufficient! you aren't too limited
//
//    but what happens if you want to store something like a color or string?
//
//    imagine the following scenario: you place a signpost actor in your new
//    level, and then you specify what text should be on the signpost, as well
//    as what color it is, and you do all this directly in the level editor
//    
//    this system makes that possible; a simple way to describe it would be
//    to say it retrofits prefabs from modern game engines into zelda oot
//
// no level editor has implemented payloads yet, but i plan to
// add this functionality to z64scene someday
//
// in anticipation of actor payloads eventually being supported
// by z64scene and/or SharpOcarina, here are two examples:
//
// example 1: plain blob
//
//    say you have the following structs are embedded into CustomSignpost.h:
//
//       typedef struct {
//           Color_RGB8 color;
//       } CustomSignpostPayload;
//
//       typedef struct {
//           Actor actor;
//           const CustomSignpostPayload *payload;
//       } CustomSignpost;
//
//    and then say the room file has a payload with the bytes: ff 00 00
//
//    in your actor's Init() routine, you can do the following:
//
//       this->payload = Actor_GetPayload(&this->actor, play);
//
//    and in your actor's Draw() routine, you can access this->payload->color
//    to perhaps set the primColor register or do some other meaningful thing
//    using that variable
//
// example 2: working with pointers
//
//    expanding on the same struct from earlier:
//
//       typedef struct {
//           Color_RGB8 color;
//           const char *text;
//       } CustomSignpostPayload;
//
//       typedef struct {
//           Actor actor;
//           const CustomSignpostPayload *payload;
//       } CustomSignpost;
//
//    now the payload bytes might look something like this:
//
//       ff0000xx 030028b0   (xx is padding generated by the compiler
//                            to ensure the pointer bytes are aligned)
//
//    in your actor's Init() routine, you can do the following:
//
//       this->payload = Actor_GetPayload(
//                           &this->actor, play
//                           , offsetof(CustomSignpostPayload, text)
//                       );
//
//    notice the use of offsetof() here to tell Actor_GetPayload() that
//    there is a pointer that needs to be translated from a segment address
//    (0x030028b0) to a physical address (e.g. 0x80102030) so that you can
//    start using the pointer (you can use multiple offsetof()'s if your
//    actor's payload contains multiple pointers)
//
//    in your actor's Update() routine, you can then use the pointer like so:
//
//       EasyTalkNpc(&this->actor, play, .string = this->payload->text);
//
// important things to know:
//
//   1.  Actor_GetPayload() is intended to only be invoked from within
//       your actor's Init() routine
//
//   2.  Actor_GetPayload() should only be run once per actor
//

#include <uLib.h>

// will only be changed in this compilation unit
static u16 gNumSetupActorsSafe;

Asm_VanillaHook(Scene_CommandActorList);
void Scene_CommandActorList(PlayState* play, SceneCmd* cmd)
{
	play->numSetupActors = gNumSetupActorsSafe = cmd->actorList.length;
	play->setupActorList = SEGMENTED_TO_VIRTUAL(cmd->actorList.data);
}

void *(Actor_GetPayload)(Actor *actor, PlayState *play)
{
	// actor payload data starts immediately after actor setup list
	u32 *payloadBlock = (u32*)(&play->setupActorList[gNumSetupActorsSafe]);
	
	return &payloadBlock[(u16)(actor->params)];
}

void *Actor_GetPayloadAndDoRelocs(Actor *actor, PlayState *play, u8 *relocs)
{
	void *oldSeg3 = gSegments[3];
	u8 *data = (Actor_GetPayload)(actor, play);
	
	gSegments[3] = VIRTUAL_TO_PHYSICAL(play->roomCtx.unk_34);
	for ( ; *relocs != 0xff; ++relocs)
	{
		u32 *tmp = ((u32*)data) + *relocs;
		
		*tmp = (u32)SEGMENTED_TO_VIRTUAL(*tmp);
	}
	
	gSegments[3] = oldSeg3;
	return data;
}

